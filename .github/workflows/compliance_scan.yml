name: Compliance Security Scan

on:
  pull_request:
    types: [opened, synchronize, reopened]
  # push:
  #   branches: [main, develop]
  # schedule:
  #   - cron: '0 0 * * *'  # Daily scans at midnight
  workflow_dispatch:
    inputs:
      auto_fix:
        description: 'Enable auto-fix for security issues'
        required: false
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'

jobs:
  compliance-scan:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      security-events: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: pip install boto3 requests
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ vars.AWS_REGION || 'us-east-1' }}
    
    - name: Set scan parameters
      id: params
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          AUTO_FIX="${{ github.event.inputs.auto_fix }}"
        elif [ "${{ github.event_name }}" = "schedule" ]; then
          AUTO_FIX="true"   # Enable auto-fix for scheduled scans
        elif [ "${{ github.event_name }}" = "pull_request" ]; then
          AUTO_FIX="${{ vars.PR_AUTO_FIX || 'true' }}"   # Configurable via repository variable
        else
          AUTO_FIX="false"  # Default for push events
        fi
        echo "auto_fix=$AUTO_FIX" >> $GITHUB_OUTPUT
        echo "Auto-fix enabled: $AUTO_FIX"
    
    - name: Run Compliance Security Scan
      env:
        AWS_REGION: ${{ vars.AWS_REGION || 'us-east-1' }}
        BEDROCK_KB_ID: ${{ vars.BEDROCK_KB_ID || '6OFPQYR1JK' }}
        BEDROCK_MODEL_ID: ${{ vars.BEDROCK_MODEL_ID || 'anthropic.claude-3-haiku-20240307-v1:0' }}
        REPORTS_S3_BUCKET: ${{ vars.REPORTS_S3_BUCKET || 'ai-security-scanner-reports-1759503117' }}
        GITHUB_PR_NUMBER: ${{ github.event.number }}
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        GITHUB_REPOSITORY: ${{ github.repository }}
        DISABLE_PYTHON_PR_COMMENT: "true"
      run: |
        SCAN_ARGS=""
        if [ "${{ steps.params.outputs.auto_fix }}" = "true" ]; then
          SCAN_ARGS="--fix  --skip-cve"
        fi
        echo "Running: python src/compliance_scanner.py $SCAN_ARGS"
        echo "Repository: $GITHUB_REPOSITORY"
        echo "Branch: $GITHUB_REF_NAME"
        echo "PR Number: $GITHUB_PR_NUMBER"
        echo "Using AWS Region: $AWS_REGION"
        echo "Using KB ID: $BEDROCK_KB_ID"
        echo "Using Model: $BEDROCK_MODEL_ID"
        echo "Using S3 Bucket: $REPORTS_S3_BUCKET (includes cache persistence)"
        python src/compliance_scanner.py $SCAN_ARGS
    
    - name: Generate PR Comment
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          let comment = `## 🔒 AI-Powered Compliance Security Scan Results\n\n`;
          comment += `**Auto-fix:** ${{ steps.params.outputs.auto_fix }}\n`;
          comment += `**Model:** ${{ vars.BEDROCK_MODEL_ID || 'anthropic.claude-3-haiku-20240307-v1:0' }}\n`;
          comment += `**Knowledge Base:** ${{ vars.BEDROCK_KB_ID || '6OFPQYR1JK' }}\n`;
          comment += `**Region:** ${{ vars.AWS_REGION || 'us-east-1' }}\n\n`;
          
          if (fs.existsSync('compliance_report.json')) {
            const report = JSON.parse(fs.readFileSync('compliance_report.json', 'utf8'));
            
            comment += `### 📊 Summary\n`;
            comment += `- **Files scanned:** ${report.files_scanned || 0}\n`;
            comment += `- **Total issues:** ${report.total_issues || 0}\n`;
            comment += `- **AI calls:** ${report.ai_calls || 0}\n`;
            comment += `- **Cost:** $${(report.cost || 0).toFixed(4)}\n`;
            
            if (report.fixed > 0) {
              comment += `- **Auto-fixed:** ${report.fixed} files ✅\n`;
            }
            
            // Vulnerability summary
            const vulnSummary = report.vulnerability_summary || {};
            if (vulnSummary.total_vulnerabilities > 0) {
              comment += `- **Vulnerabilities:** ${vulnSummary.total_vulnerabilities} (Critical: ${vulnSummary.critical_vulns || 0}, CVEs: ${vulnSummary.cve_findings || 0})\n`;
            }
            
            comment += `\n### 🎯 Issues by Severity\n`;
            const bySevrityData = report.by_severity || {};
            let hasSeverityIssues = false;
            
            // Check both lowercase and uppercase severity keys
            const allSeverities = {...bySevrityData};
            for (const [key, value] of Object.entries(bySevrityData)) {
              if (value > 0) {
                hasSeverityIssues = true;
                const emoji = key.toLowerCase() === 'critical' ? '🔴' : 
                             key.toLowerCase() === 'high' ? '🟠' : 
                             key.toLowerCase() === 'medium' ? '🟡' : '🟢';
                comment += `- ${emoji} **${key.toUpperCase()}**: ${value}\n`;
              }
            }
            
            if (!hasSeverityIssues && (report.total_issues || 0) === 0) {
              comment += `✅ No issues found\n`;
            }
            
            // Compliance violations summary
            if (Object.keys(report.compliance_summary || {}).length > 0) {
              comment += `\n### 📋 Compliance Standards Violated\n`;
              for (const [standard, data] of Object.entries(report.compliance_summary)) {
                comment += `- **${standard}**: ${data.issues} issues`;
                if (data.critical > 0) comment += ` (🔴 ${data.critical} critical)`;
                if (data.high > 0) comment += ` (🟠 ${data.high} high)`;
                comment += `\n`;
              }
            }
            
            // Detailed findings by file - match original format
            if (report.results && report.results.length > 0) {
              let hasAnyIssues = false;
              
              // Check if any file has issues
              for (const result of report.results) {
                if (result.issues && result.issues.length > 0) {
                  hasAnyIssues = true;
                  break;
                }
              }
              
              if (hasAnyIssues) {
                comment += `\n### 🔍 Detailed Findings\n\n`;
                
                for (const result of report.results) {
                  if (result.issues && result.issues.length > 0) {
                    comment += `#### 📁 \`${result.filepath}\` (${result.language})\n\n`;
                    
                    // Sort issues by severity
                    const severityOrder = { 'critical': 0, 'high': 1, 'medium': 2, 'low': 3, 'CRITICAL': 0, 'HIGH': 1, 'MEDIUM': 2, 'LOW': 3 };
                    result.issues.sort((a, b) => (severityOrder[a.severity] || 99) - (severityOrder[b.severity] || 99));
                    
                    for (const issue of result.issues) {
                      const severity = issue.severity.toUpperCase();
                      const emoji = severity === 'CRITICAL' ? '🔴' : severity === 'HIGH' ? '🟠' : severity === 'MEDIUM' ? '🟡' : '🟢';
                      
                      comment += `${emoji} Line ${issue.line} (${severity}): ${issue.description}\n`;
                      
                      if (issue.compliance_violations && issue.compliance_violations.length > 0) {
                        comment += `📋 Violates: ${issue.compliance_violations.join(', ')}\n`;
                      }
                      
                      if (issue.rfc_document) {
                        comment += `📄 RFC Document: ${issue.rfc_document}\n`;
                      }
                      
                      if (issue.s3_sources && issue.s3_sources.length > 0) {
                        comment += `🗂️ S3 Sources: ${issue.s3_sources.join(', ')}\n`;
                      }
                      
                      if (issue.kb_rule) {
                        comment += `📚 KB Rule: ${issue.kb_rule}\n`;
                      }
                      
                      if (issue.rule_source) {
                        comment += `🔗 Source: ${issue.rule_source}\n`;
                      }
                      
                      if (issue.remediation) {
                        comment += `🔧 Fix: ${issue.remediation}\n`;
                      }
                      
                      comment += `\n`;
                    }
                  }
                }
              }
            }
            
            // Action required section
            const criticalCount = (report.by_severity.critical || 0) + (report.by_severity.CRITICAL || 0);
            const vulnCritical = report.vulnerability_summary?.critical_vulns || 0;
            
            comment += `\n### 🚨 Action Required\n`;
            if (criticalCount > 0 || vulnCritical > 0) {
              comment += `❌ **PR BLOCKED** - ${criticalCount + vulnCritical} critical issues must be resolved\n\n`;
              comment += `**Steps to resolve:**\n`;
              comment += `1. Review all critical issues listed above\n`;
              comment += `2. Apply suggested fixes or update dependencies\n`;
              comment += `3. Re-run the scan to verify fixes\n`;
              comment += `4. Ensure no new critical issues are introduced\n`;
            } else {
              comment += `✅ **No critical issues** - PR can be merged\n\n`;
              if (report.total_issues > 0) {
                comment += `**Recommendations:**\n`;
                comment += `1. Review and address high/medium severity findings\n`;
                comment += `2. Consider fixing before production deployment\n`;
              }
            }
            
          } else {
            comment += `❌ **Scan failed** - No compliance report generated\n`;
            comment += `Check the workflow logs for details.\n`;
          }
          
          // Post the comment
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: comment
          });
    
    - name: Block on Critical Issues
      run: |
        if [ -f "compliance_report.json" ]; then
          CRITICAL=$(jq -r '.by_severity.critical // 0' compliance_report.json)
          if [ "$CRITICAL" -gt 0 ] && [ "${{ github.event_name }}" = "pull_request" ]; then
            echo "❌ $CRITICAL critical security issues found. Blocking PR merge."
            exit 1
          fi
        fi
    
    - name: Upload Artifacts
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: compliance-reports
        path: |
          compliance_report.json
          error_log.txt
